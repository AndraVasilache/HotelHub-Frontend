{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { useState, useEffect } from 'react';\nimport { MaskService } from 'react-native-masked-text';\nimport defaultValidation from \"../FormItems/defaultValidations\";\n\nvar useCustomForm = function useCustomForm(formFields, callback, validate) {\n  var formInitialState = getInitialFormState();\n\n  var _useState = useState(_objectSpread({}, formInitialState)),\n      _useState2 = _slicedToArray(_useState, 2),\n      fields = _useState2[0],\n      setFields = _useState2[1];\n\n  var _useState3 = useState(),\n      _useState4 = _slicedToArray(_useState3, 2),\n      isValidFormData = _useState4[0],\n      setIsValidFormData = _useState4[1];\n\n  var _useState5 = useState(),\n      _useState6 = _slicedToArray(_useState5, 2),\n      isDirtyFormData = _useState6[0],\n      setIsDirtyFormData = _useState6[1];\n\n  var _useState7 = useState({}),\n      _useState8 = _slicedToArray(_useState7, 2),\n      errors = _useState8[0],\n      setErrors = _useState8[1];\n\n  var _useState9 = useState(false),\n      _useState10 = _slicedToArray(_useState9, 2),\n      isSubmitting = _useState10[0],\n      setIsSubmitting = _useState10[1];\n\n  useEffect(function () {\n    var skipFieldType = ['boolean', 'button', 'customComponent'];\n    var filteredFields = getFormFields().filter(function (_ref) {\n      var type = _ref.type;\n      return !skipFieldType.includes(type);\n    });\n    var isFilled = filteredFields.every(function (field) {\n      return !!fields[field.name].value;\n    });\n    setIsValidFormData(isFilled);\n    var isDirty = formFields.some(function (field) {\n      switch (field.type) {\n        case 'boolean':\n          return fields[field.name] !== getFormFieldDefaultValue(field);\n\n        default:\n          return !!fields[field.name];\n      }\n    });\n    setIsDirtyFormData(isDirty);\n  }, [fields]);\n  useEffect(function () {\n    setIsSubmitting(false);\n\n    if (Object.keys(errors).length === 0 && isSubmitting && isValidFormData) {\n      return callback(fields);\n    }\n\n    return function () {\n      return undefined;\n    };\n  }, [errors]);\n\n  function getFormFieldDefaultValue(_ref2) {\n    var defaultValue = _ref2.defaultValue,\n        type = _ref2.type;\n\n    if (defaultValue !== undefined) {\n      return defaultValue;\n    }\n\n    switch (type) {\n      case 'boolean':\n        return false;\n\n      default:\n        return '';\n    }\n  }\n\n  function getFormFields() {\n    var auxFields = [];\n    formFields.map(function (row) {\n      return auxFields.push.apply(auxFields, _toConsumableArray(row));\n    });\n    return auxFields;\n  }\n\n  function getInitialFormState() {\n    var formFieldNames = getFormFields().reduce(function (obj, field) {\n      var value = getFormFieldDefaultValue(field);\n\n      var fld = _objectSpread({}, obj);\n\n      fld[field.name] = {\n        value: value\n      };\n      return fld;\n    }, {});\n    return formFieldNames;\n  }\n\n  var resetForm = function resetForm() {\n    setErrors({});\n    setFields(formInitialState);\n  };\n\n  var handleOnChangeValue = function handleOnChangeValue(fieldName) {\n    return function (text) {\n      var toMask = getFormFields().filter(function (f) {\n        return f.name === fieldName;\n      }).reduce(function (obj, item) {\n        return {\n          maskType: getDefaultMaskType(item.type),\n          mask: item.mask\n        };\n      }, {});\n      var masked = toMask.maskType ? MaskService.toMask(toMask.maskType, text, toMask.mask) : text;\n      setFields(_objectSpread(_objectSpread({}, fields), {}, _defineProperty({}, fieldName, {\n        value: masked,\n        rawValue: text\n      })));\n    };\n  };\n\n  var getDefaultMaskType = function getDefaultMaskType(type) {\n    var types = ['credit-card', 'cpf', 'cnpj', 'zip-code', 'only-numbers', 'money', 'cel-phone', 'datetime'];\n\n    if (types.includes(type)) {\n      return type;\n    }\n\n    return null;\n  };\n\n  var handleOnSubmitForm = function handleOnSubmitForm() {\n    setIsSubmitting(true);\n    var defaultErrors = defaultValidation(getFormFields());\n    var customErrors = validate(fields);\n    debugger;\n\n    var returnedErrors = _objectSpread(_objectSpread({}, defaultErrors), customErrors);\n\n    setErrors(returnedErrors);\n  };\n\n  return {\n    fields: fields,\n    errors: errors,\n    isSubmitting: isSubmitting,\n    handleOnSubmitForm: handleOnSubmitForm,\n    resetForm: resetForm,\n    handleOnChangeValue: handleOnChangeValue,\n    isValidFormData: isValidFormData,\n    isDirtyFormData: isDirtyFormData\n  };\n};\n\nexport default useCustomForm;","map":{"version":3,"sources":["/home/mira/Desktop/hotelhub_frontend/node_modules/react-native-form4u/src/components/Form4u/hooks/useForm4u.js"],"names":["useState","useEffect","MaskService","defaultValidation","useCustomForm","formFields","callback","validate","formInitialState","getInitialFormState","fields","setFields","isValidFormData","setIsValidFormData","isDirtyFormData","setIsDirtyFormData","errors","setErrors","isSubmitting","setIsSubmitting","skipFieldType","filteredFields","getFormFields","filter","type","includes","isFilled","every","field","name","value","isDirty","some","getFormFieldDefaultValue","Object","keys","length","undefined","defaultValue","auxFields","map","row","push","formFieldNames","reduce","obj","fld","resetForm","handleOnChangeValue","fieldName","text","toMask","f","item","maskType","getDefaultMaskType","mask","masked","rawValue","types","handleOnSubmitForm","defaultErrors","customErrors","returnedErrors"],"mappings":"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","sourcesContent":["import { useState, useEffect } from 'react';\nimport { MaskService } from 'react-native-masked-text';\nimport defaultValidation from '../FormItems/defaultValidations';\n\nconst useCustomForm = (formFields, callback, validate) => {\n  const formInitialState = getInitialFormState();\n\n  const [fields, setFields] = useState({ ...formInitialState });\n  const [isValidFormData, setIsValidFormData] = useState();\n  const [isDirtyFormData, setIsDirtyFormData] = useState();\n  const [errors, setErrors] = useState({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  useEffect(() => {\n    /**\n     * Check if all fields have been filled out.\n     */\n    // filter out fields which does not need to be checked if they are filled out\n    const skipFieldType = ['boolean', 'button', 'customComponent'];\n    const filteredFields = getFormFields().filter(({ type }) => !skipFieldType.includes(type));\n\n    // check if all remaining fields have been filled out\n    const isFilled = filteredFields.every(field => !!fields[field.name].value);\n    setIsValidFormData(isFilled);\n\n    /**\n     * Check if at least one field has been filled out.\n     */\n    const isDirty = formFields.some((field) => {\n      switch (field.type) {\n        case 'boolean':\n          // because Boolean fields will have a default value,\n          // we need to check if the current value is not the default one\n          return fields[field.name] !== getFormFieldDefaultValue(field);\n\n        default:\n          return !!fields[field.name];\n      }\n    });\n    setIsDirtyFormData(isDirty);\n  }, [fields]);\n\n  /**\n   * If there are any errors, then prevent of calling the callback function\n   */\n  useEffect(() => {\n    setIsSubmitting(false);\n    if (Object.keys(errors).length === 0 && isSubmitting && isValidFormData) {\n      return callback(fields);\n    }\n    return () => undefined;\n  }, [errors]);\n\n  /**\n   * Determine what should be the default value\n   * for a given field.\n   */\n  function getFormFieldDefaultValue({ defaultValue, type }) {\n    if (defaultValue !== undefined) {\n      return defaultValue;\n    }\n\n    switch (type) {\n      case 'boolean':\n        return false;\n      default:\n        return '';\n    }\n  }\n\n  /**\n   * Extract our form fields from each row\n   * and compose one big list of field objects.\n   */\n  function getFormFields() {\n    const auxFields = [];\n    formFields.map(row => auxFields.push(...row));\n    return auxFields;\n  }\n\n  /**\n   * dynamically construct initial state by using\n   * each form field's name as an object property.\n   */\n  function getInitialFormState() {\n    const formFieldNames = getFormFields().reduce((obj, field) => {\n      const value = getFormFieldDefaultValue(field);\n      const fld = { ...obj };\n      fld[field.name] = { value };\n      return fld;\n    }, {});\n\n    return formFieldNames;\n  }\n\n  /**\n   * Reset Form to its initial state\n   */\n  const resetForm = () => {\n    setErrors({});\n    setFields(formInitialState);\n  };\n\n  /**\n   * Handle callback onChangeValue from inputs and other components\n   */\n  const handleOnChangeValue = fieldName => (text) => {\n    // check if field needs to be masked\n    const toMask = getFormFields()\n      .filter(f => f.name === fieldName)\n      .reduce(\n        (obj, item) => ({\n          maskType: getDefaultMaskType(item.type),\n          mask: item.mask,\n        }),\n        {},\n      );\n\n    // mask field if needed\n    const masked = toMask.maskType ? MaskService.toMask(toMask.maskType, text, toMask.mask) : text;\n\n    setFields({ ...fields, [fieldName]: { value: masked, rawValue: text } });\n  };\n\n  /** Used to get default mask types for fields\n   *  Uses same default types as in react-native-masked-text\n   */\n  const getDefaultMaskType = (type) => {\n    const types = [\n      'credit-card',\n      'cpf',\n      'cnpj',\n      'zip-code',\n      'only-numbers',\n      'money',\n      'cel-phone',\n      'datetime',\n    ];\n    if (types.includes(type)) {\n      return type;\n    }\n    return null;\n  };\n\n  const handleOnSubmitForm = () => {\n    setIsSubmitting(true); // prevents the form from submitting on render\n    const defaultErrors = defaultValidation(getFormFields());\n    const customErrors = validate(fields);\n    debugger;\n    const returnedErrors = { ...defaultErrors, ...customErrors };\n    setErrors(returnedErrors);\n  };\n\n  return {\n    fields,\n    errors,\n    isSubmitting,\n    handleOnSubmitForm,\n    resetForm,\n    handleOnChangeValue,\n    isValidFormData,\n    isDirtyFormData,\n  };\n};\n\nexport default useCustomForm;\n"]},"metadata":{},"sourceType":"module"}